<!doctype html>
<html>
<head>
<title>Bismuth</title>
<style>
body {
    text-align: center;
    font-family: Arial;
}
h1, h2, h3, h4, p, div, ul {
    text-align: justify;
}
#sourcecode {
    font-family: Consolas, "Courier New", monospace;
    width: 100%;
    margin-top: 40px;
    min-height: 300px;
}
#generatedC, #generatedJS {
    white-space: pre;
    font-family: Consolas, "Courier New", monospace
}
#errors {
    font-family: Arial;
    color: #A00;
}
</style>
</head>
<body>
    <script src="build/build.js"></script>
    <h1>Bismuth - Run Online</h1>
    <p>Bismuth is a pure, strongly and statically-typed <em>imperative</em> programming language that keeps code predictable and easy to refactor.</p>
    <p>Bismuth currently supports type-generic functions and data types, with generic constraints in-the-works.</p>
    <p>Functions specify their side-effects through <em>effect signatures</em>.
        These signatures offer similar benefits to the "dependency-injection" style used by many languages and frameworks to improve testability.
    </p>
    <p>
        Bismuth will hopefully soon offer additional features:
        <ul>
        <li>a form of linear or unique typing, to better model resources like memory;
        <li>a form of flow-typing or static precondition check to eliminate error cases statically;
        <li>a protocol specification language that allows system properties to be verified;
        <li>a reflection suite to eliminate repetitive boilerplate;
        <li>a reference-counting memory reclaimation system that avoids the need for expensive GC operations (when targeting C).
        </ul>
    </p>
    <p>
        The Bismuth compiler is written in TypeScript.
        You can run it on this page to produce runnable JavaScript.
        Future versions will also target C.
    </p>
    <textarea id="sourcecode">

interface Read {
	func read(String) -> self;
}

struct Box {
	var x: String;
}

instance Read for Box {
	func read(s: String) -> Box {
		return #Box{
			x => s
		};
	}
}

func readMany[T is Read](xs: Array[String]) -> Array[T] {
	var result: Array[T] = #[];
	var i: Int = 0;
	while less(i, length(xs)) {
		var s: String = at(xs, i);
		var y: T = read(s);
		result = append(result, #[y]);
		i = add(i, 1);
	}
	return result;
}

func main!IO() {
	var ins: Array[String] = #["abc", "def", "ghi"];
	var outs: Array[Box] = readMany(ins);
	var i: Int = 0;
	while less(i, length(outs)) {
		print!("next is:");
		print!(at(outs, i).x);
		i = add(i, 1);
	}
}


</textarea>
<script>
document.getElementById("sourcecode").addEventListener("keydown", (e) => {
    // https://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea
    if (e.keyCode == 9) {
        e.preventDefault();
        var start = e.target.selectionStart;
        var end = e.target.selectionEnd;
        // set textarea value to: text before caret + tab + text after caret
        e.target.value = e.target.value.substr(0, start) + "\t" + e.target.value.substr(end);
        // put caret at right position again
        e.target.selectionStart = e.target.selectionEnd = start + 1;
        return;
    }
    if (e.keyCode == 13) {
        // add newline with tabs
        e.preventDefault();
        var start = e.target.selectionStart;
        var end = e.target.selectionEnd;

        let insert = "";
        for (let i = start-1; i >= 0; i--) {
            const c = e.target.value.charAt(i);
            if (c == "\t") {
                insert = c + insert;
            } else if (c == "\n") {
                break;
            } else {
                insert = "";
            }
        }
        insert = "\n" + insert;
        if (e.target.value.charAt(start-1) == "{") {
            insert += "\t";
        }
        // set textarea value to: text before caret + tab + text after caret
        e.target.value = e.target.value.substr(0, start) + insert + e.target.value.substr(end);
        // put caret at right position again
        e.target.selectionStart = e.target.selectionEnd = start + insert.length;
        return;
    }
    if (e.key == "}") {
        // de-indent by one tab before inserting
        var start = e.target.selectionStart;
        var end = e.target.selectionEnd;

        if (e.target.value.charAt(start-1) == "\t") {
            e.preventDefault();
            e.target.value = e.target.value.substr(0, start-1) + "}" + e.target.value.substr(end);
            e.target.selectionStart = e.target.selectionEnd = start;
        }
        return;
    }
});
</script>
    <script>
        let last = "";
        let compiled = false;
        setInterval(function() {
            let current = document.getElementById('sourcecode').value;
            if (current == last) {
                if (!compiled) {
                    compile(current);
                    compiled = true;
                }
            } else {
                compiled = false;
                last = current;
            }
        }, 500);
    </script>
    <div id="errors"></div>
    <div id="generatedJS" style="display:none"></div>
    <hr/>
    <div id="generatedC"></div>
</body>
</html>