<!doctype html>
<html>
<head>
<title>Bismuth</title>
<style>
body {
    text-align: center;
    font-family: Arial;
}
h1, h2, h3, h4, p, div, ul {
    text-align: justify;
}
#sourcecode {
    font-family: Consolas, "Courier New", monospace;
    width: 100%;
    margin-top: 40px;
    min-height: 300px;
}
#generatedC, #generatedJS {
    white-space: pre;
    font-family: Consolas, "Courier New", monospace
}
#errors {
    font-family: Arial;
    color: #A00;
}
</style>
</head>
<body>
    <script src="define.js"></script>
    <script src="build/build.js"></script>
    <h1>Bismuth - Run Online</h1>
    <p>Bismuth is a pure, strongly and statically-typed <em>imperative</em> programming language that keeps code predictable and easy to refactor.</p>
    <p>Bismuth currently supports type-generic functions and data types, with generic constraints in-the-works.</p>
    <p>Functions specify their side-effects through <em>effect signatures</em>.
        These signatures offer similar benefits to the "dependency-injection" style used by many languages and frameworks to improve testability.
    </p>
    <p>
        Bismuth will hopefully soon offer additional features:
        <ul>
        <li>a form of linear or unique typing, to better model resources like memory;
        <li>a form of flow-typing or static precondition check to eliminate error cases statically;
        <li>a protocol specification language that allows system properties to be verified;
        <li>a reflection suite to eliminate repetitive boilerplate;
        <li>a reference-counting memory reclaimation system that avoids the need for expensive GC operations (when targeting C).
        </ul>
    </p>
    <p>
        The Bismuth compiler is written in TypeScript.
        You can run it on this page to produce runnable JavaScript.
        Future versions will also target C.
    </p>
    <textarea id="sourcecode">

            interface ToString {
                func str(self) -> String;
            }
            
            instance ToString for Pair {
                func str(p: Pair) -> String {
                    return appendString(p.x, p.y);
                }
            }
            
            struct Pair {
                var x: String;
                var y: String;
            }
            
            func main!IO {
                print!(str(#Pair{y => "xyz", x => "abc"}));
            }
            
            
</textarea>
<div style="display: none">
interface Inc {
	func inc(self) -> self;
}

struct Count {
	var c: Int;
}

instance Inc for Count {
	func inc(c: Count) -> Count {
		return #Count{ c => c.c + 1 };
	}
}

struct Pair[T] {
	var first: T;
	var second: T;
}

instance Inc [T is Inc] for Pair[T] {
	func inc(p: Pair[T]) -> Pair[T] {
		return #Pair{
			first => inc(p.first),
			second => inc(p.second)
		};
	}
}

func incPair[T is Inc](p2: Pair[T]) -> Pair[T] {
	return #Pair{
		first => inc(p2.first),
		second => inc(p2.second)
	};
}


func example() -> Pair[Count] {
	var p: Pair[Count] = #Pair{
		first => #Count{c => 4},
		second => #Count{c => 7}
	};
	var q: Pair[Count] = inc(p);
	return q;
}

func main!IO() {
}

</div>

<script>



document.getElementById("sourcecode").addEventListener("keydown", (e) => {
    // https://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea
    if (e.keyCode == 9) {
        e.preventDefault();
        var start = e.target.selectionStart;
        var end = e.target.selectionEnd;
        // set textarea value to: text before caret + tab + text after caret
        e.target.value = e.target.value.substr(0, start) + "\t" + e.target.value.substr(end);
        // put caret at right position again
        e.target.selectionStart = e.target.selectionEnd = start + 1;
        return;
    }
    if (e.keyCode == 13) {
        // add newline with tabs
        e.preventDefault();
        var start = e.target.selectionStart;
        var end = e.target.selectionEnd;

        let insert = "";
        for (let i = start-1; i >= 0; i--) {
            const c = e.target.value.charAt(i);
            if (c == "\t") {
                insert = c + insert;
            } else if (c == "\n") {
                break;
            } else {
                insert = "";
            }
        }
        insert = "\n" + insert;
        if (e.target.value.charAt(start-1) == "{") {
            insert += "\t";
        }
        // set textarea value to: text before caret + tab + text after caret
        e.target.value = e.target.value.substr(0, start) + insert + e.target.value.substr(end);
        // put caret at right position again
        e.target.selectionStart = e.target.selectionEnd = start + insert.length;
        return;
    }
    if (e.key == "}") {
        // de-indent by one tab before inserting
        var start = e.target.selectionStart;
        var end = e.target.selectionEnd;

        if (e.target.value.charAt(start-1) == "\t") {
            e.preventDefault();
            e.target.value = e.target.value.substr(0, start-1) + "}" + e.target.value.substr(end);
            e.target.selectionStart = e.target.selectionEnd = start;
        }
        return;
    }
});
</script>
    <script>
        let compile = obtain("compile").compile;
        let last = "";
        let compiled = false;
        setInterval(function() {
            let current = document.getElementById('sourcecode').value;
            if (current == last) {
                if (!compiled) {
                    compile(current);
                    compiled = true;
                }
            } else {
                compiled = false;
                last = current;
            }
        }, 500);
    </script>
    <div id="errors"></div>
    <div id="generatedJS" style="display:none"></div>
    <hr/>
    <div id="generatedC"></div>
</body>
</html>